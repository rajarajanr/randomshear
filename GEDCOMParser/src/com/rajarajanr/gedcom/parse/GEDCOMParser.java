package com.rajarajanr.gedcom.parse;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import com.rajarajanr.gedcom.exception.GEDCOMParserException;
import com.rajarajanr.gedcom.exception.TokenizerException;
import com.rajarajanr.gedcom.exception.XMLCreationException;

/**
 * <p>
 * <b>Title: </b>GEDCOMParser.java
 * </p>
 * <p>
 * <b>Description: </b> The Parser to parse the GEDCOM file and generate the XML
 * output; Pass the input file to the main method
 * </p>
 * <p>
 * <b>@author Originator:</b> rrajendran
 * <p>
 * <br>
 * 
 */
public class GEDCOMParser {
	protected static final String OUTPUT_XML = "output.xml";

	/*
	 * Pattern to extract the level, tag-or-id and [data] from each line in the
	 * input file
	 */
	private final static Pattern lineFormat = Pattern
			.compile("^(?<level>[0-9]+)\\s+(?<tagOrId>((@[\\w]+@)|([A-Z]{3,4})))((\\s+)|($))(?<data>.*)$");

	/**
	 * The main method; call with input file path as parameter and an optional
	 * output file path as second parameter; if output path is not provided a
	 * file called output.xml is generated by default.
	 * 
	 * @param String
	 *            inFile
	 * @param String
	 *            outFile{optional}
	 * 
	 */
	public static void main(String[] args) {
		if (0 == args.length) {
			System.out.println("Please provide the input file as parameter");
		} else {
			final String inputFilePath = args[0];
			String outFile = null;
			if (2 == args.length) {
				outFile = args[1];
			}
			/* Extract the input file path */
			/* read the complete input file and store it in a list */
			List<String> lines = readFile(inputFilePath);

			/* If input file was read properly continue */
			if (null != lines) {
				try {
					createXML(tokenizeAllLines(lines),
							((null != outFile) ? outFile : OUTPUT_XML));
				} catch (GEDCOMParserException e) {
					System.out.println("Error Occured\n" + e.getMessage());
				}
			}
		}
	}

	/**
	 * Reads the given file and returns the content
	 * 
	 * @param path
	 *            - the path of the file to read
	 * @return List<String> - A List containing each line from the input file as
	 *         a string
	 */
	protected static List<String> readFile(final String path) {
		List<String> lines = null;
		try {
			lines = Files.readAllLines(Paths.get(path),
					Charset.forName("UTF-8"));

		} catch (IOException e) {
			System.out.println("Error While reading input file\n"
					+ e.getMessage());
		} finally {

		}
		return lines;
	}

	/**
	 * Tokenizes all the lines in the list(calls tokenizeLine input.list.size
	 * times to get the job done)
	 * 
	 * @param lines
	 *            - list of lines to tokenize
	 * @return List<String[]> - list of String arrays; each string array
	 *         contains 3 items - level, tagOrId, data in that order
	 * @throws TokenizerException
	 *             - in case the passed list is null
	 */
	protected static List<String[]> tokenizeAllLines(List<String> lines)
			throws TokenizerException {
		if (null == lines) {
			throw new TokenizerException("Input list Null");
		}
		List<String[]> elementsList = new ArrayList<String[]>();
		for (String line : lines) {
			elementsList.add(tokenizeLine(line));
		}
		return elementsList;
	}

	/**
	 * Tokenizes the passed string
	 * 
	 * @param line
	 *            - String to be tokenized
	 * @return String[] - contains 3 strings - level, tagOrId, data in that
	 *         order
	 * @throws TokenizerException
	 *             - in case input string is null or Input not well
	 *             formed(doesnt adhere to GEDCOM format)
	 */
	protected static String[] tokenizeLine(String line)
			throws TokenizerException {
		if (null == line) {
			throw new TokenizerException("Input String Null");
		}
		Matcher match = lineFormat.matcher(line);
		if (match.find()) {
			final String[] elements = { match.group("level"),
					match.group("tagOrId"), match.group("data") };
			return elements;
		} else {
			throw new TokenizerException("Input not well formed");
		}
	}

	/**
	 * Takes the tokenized items and generates the output XML
	 * 
	 * @param tokenizedList
	 *            - List<String[]> - contains all the lines from the input file
	 *            tokenized as per the GEDCOM format
	 * @param outFile
	 *            - outputXML file path
	 * @throws XMLCreationException
	 *             - in case an error occurs while writing XML or input is
	 *             logically not well formed
	 */
	protected static void createXML(List<String[]> tokenizedList, String outFile)
			throws XMLCreationException {
		/* Create XML doc */
		XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
		XMLStreamWriter writer = null;
		// boolean failure = true;
		try {

			writer = outputFactory
					.createXMLStreamWriter(new FileWriter(outFile));
			/* Start root element */
			writer.writeStartElement("gedcom");
			/* keep track of the previous level */
			int previousLevel = -1;
			/* iterate through the tokenized elements and create the xml doc */
			for (String[] elements : tokenizedList) {
				String level = elements[0];
				String tagOrId = elements[1];
				String data = elements[2];
				int currentLevel = Integer.parseInt(level);
				/*
				 * In case the tagOrId is a unique identifier start a new
				 * subtree
				 */
				if (isNewSubTree(tagOrId)) {
					/* close all the open elements from the previous subtree */
					for (int levelDepth = 0; levelDepth <= previousLevel; levelDepth++) {
						writer.writeEndElement();
					}
					writer.writeStartElement(data);
					writer.writeAttribute("id", tagOrId);
				} else {
					switch (currentLevel - previousLevel) {
					case 0:/*
							 * both the previous node and the current entry are
							 * on the same level; close previous tag and write
							 * current tag and data
							 */
						writer.writeEndElement();
						writer.writeStartElement(tagOrId);
						writer.writeCharacters(data);
						break;
					case 1:/*
							 * current node is a child of previous node; no need
							 * to close previous tag, just write the current tag
							 * and data
							 */
						writer.writeStartElement(tagOrId);
						writer.writeCharacters(data);
						break;
					case -1:/*
							 * current node is one above previous node; close
							 * the previous two tags, write the current tag and
							 * data
							 */
						writer.writeEndElement();
						writer.writeEndElement();
						writer.writeStartElement(tagOrId);
						writer.writeCharacters(data);
						break;
					default:
						System.out.println("invalid level in input file!!");
						throw new XMLCreationException(
								"Invalid level in input file");
					}
					;
				}
				previousLevel = currentLevel;
			}
			for (int levelDepth = 0; levelDepth <= previousLevel; levelDepth++) {
				writer.writeEndElement();
			}
			/* end of root element */
			writer.writeEndElement();
			// failure = false;
		} catch (XMLStreamException e) {
			throw new XMLCreationException("Error while writing XML", e);
		} catch (IOException e) {
			throw new XMLCreationException("Error while writing XML", e);
		} finally {
			if (null != writer) {
				try {
					writer.flush();
					writer.close();
					writer = null;
				} catch (Exception e) {
					// nothing to do
				}
			}
			// if (failure) {
			// System.out.println("failure!!");
			// File oFile = new File(outFile);
			// if (oFile.exists()) {
			// System.out.println("outfile location::"
			// + oFile.getAbsolutePath());
			// System.out.println("deleting worked::" + oFile.delete());
			// }
			// }
		}

	}

	/**
	 * Checks if the passed String adheres to the Unique identifier defined in
	 * GEDCOM format
	 * 
	 * @param tagOrId
	 *            - String to test
	 * @return boolean - true if it adheres to the format, false otherwise.
	 */
	protected static boolean isNewSubTree(String tagOrId) {
		return (null != tagOrId && tagOrId.startsWith("@") && tagOrId
				.endsWith("@"));
	}
}
